%
% h = plot_camera( pose )
% h = plot_camera( pose, scale )
% h = plot_camera( pose, scale, FOVu, FOVv )
%
%  returns a handle, h, to a patch object that looks like a camera with
%  horizontal field of view 'FOVu' and vertical field of view 'FOVv'.  The
%  camera is placed at 'pose', which is a six vector <x,y,z,r,p,q> with
%  position <x,y,z> and Euler roll-pitch-yaw angles <r,p,q>.  The optional
%  scale parameter will scale the patch size - the default is 1, which
%  corresponds to about a 10cm^3 "camera"
%
%  TODO: FOV is actually ignored right now.

function h = plot_camera_func( pose, scale, FOVu, FOVy )

	if( nargin == 1 )
		scale = 1;
		FOVu = 60;
		FOVv = 60;
	elseif( nargin == 2)
		FOVu = 60;
		FOVv = 60;
	end

    % think of x as forward
    verts = scale*[ 0  0  0; ...
                        2  1  1; ...
						2  1 -1; ...
						2 -1 -1; ...
						2 -1  1; ...   
						2  1  1; ...
						2  1 -1; ...
						2 -1 -1; ...
						2 -1  1];

    faces = [ 1 3 2; ...
              1 4 3; ... 
              1 5 4; ... 
              1 2 5; ... 
              2 3 4; ... 
              6 7 8; ... 
              6 8 9];

    vertex_colors = [ 0 1 0; ...
                      0 1 0; ...
                      0 1 0; ...
                      0 1 0; ...
                      0 1 0; ...
                      0 0 1; ...
                      0 0 1; ...
                      0 0 1; ...
                      0 0 1];

    R = eulerPQR_to_rotmat( pose(4:6) );
    T(1:3,1) = pose(1:3);
    verts = repmat(T, 1, size( verts,1 ) ) + R * verts.';
    verts = verts.';

    h = patch('Vertices', verts, 'Faces', faces, 'FaceVertexCData', ...
            vertex_colors, 'FaceColor', 'flat', ...
            'FaceLighting','phong', 'BackFaceLighting', 'lit');


